# PRP: Implement Forge Guardian in Bashew Framework

## Goal

Rewrite the functionality from three original scripts (`original/forge-guardian.sh`, `original/deploy-remote.sh`, `original/install.sh`) into a single bashew-based script (`forge-guardian.sh`) with three main verbs:

1. **`scan`** — Run security checks on all Laravel/Forge projects (auto-detected via `find $root -type d -name .git`)
2. **`install`** — Local installation on a Forge server (cron, logrotate, permissions)
3. **`deploy`** — Remote installation over SSH to one or more servers (KeyFile auth)

Plus supporting verbs: `uninstall`, `check`, `env`, `update`.

## Why

- **Consolidation**: Three separate scripts become one tool with clear verbs
- **Bashew framework**: Proper CLI parsing, .env support, logging, help text, update mechanism
- **Auto-detection**: Projects discovered via filesystem scan instead of hardcoded arrays
- **Security**: Detect injected backdoors, obfuscated shells, tampered files, suspicious crons on Laravel Forge servers

## What

### User-visible behavior

```bash
# On local machine - deploy to remote servers
forge-guardian.sh deploy -s 142.93.1.100 -s 167.99.2.200
forge-guardian.sh deploy --servers servers.txt --slack "https://hooks.slack.com/..."

# On server - install locally (sets up cron + logrotate)
sudo forge-guardian.sh install

# On server - run security scan (called by cron)
forge-guardian.sh scan
forge-guardian.sh scan --mode heal     # auto-heal threats
forge-guardian.sh scan --mode dryrun   # show what heal would do

# On server - remove
sudo forge-guardian.sh uninstall
```

### Success Criteria

- [ ] `forge-guardian.sh scan` auto-detects projects under `$root/` and runs all 5 detectors
- [ ] `forge-guardian.sh scan --mode heal` quarantines malicious files and git-restores tampered tracked files
- [ ] `forge-guardian.sh install` copies itself to `/opt/forge-guardian/`, sets up cron and logrotate
- [ ] `forge-guardian.sh deploy -s <server>` uploads script via SCP, runs remote install via SSH
- [ ] `forge-guardian.sh deploy --servers <file>` reads servers from file
- [ ] Notifications (Slack, Discord, Telegram, Email) fire when threats are found
- [ ] All config can be set via .env file OR CLI options
- [ ] `forge-guardian.sh check` shows current config values
- [ ] `bash -n forge-guardian.sh` passes
- [ ] `shellcheck forge-guardian.sh` passes (with acceptable SC directives)

---

## All Needed Context

### Documentation & References

```yaml
- file: forge-guardian.sh
  why: "Target file - bashew template with framework code below line 172. Edit ONLY above line 172."

- file: original/forge-guardian.sh
  why: "Source for scan logic: 5 detectors, malicious signatures, suspicious patterns, allowlist, quarantine, notifications"

- file: original/deploy-remote.sh
  why: "Source for deploy logic: SSH/SCP helpers, remote install script builder, server list parsing"

- file: original/install.sh
  why: "Source for install logic: auto-detect projects, cron setup, logrotate config"

- file: original/examples/servers.txt
  why: "Example servers file format (one per line, # comments)"

- file: README.md
  why: "Documents expected behavior, all CLI flags, notification setup, hardening recommendations"
```

### Current Codebase Tree

```
forge-guardian/
├── forge-guardian.sh          # Bashew template (TARGET - edit this)
├── original/
│   ├── forge-guardian.sh      # Reference: scan/detection logic
│   ├── deploy-remote.sh       # Reference: SSH deploy logic
│   ├── install.sh             # Reference: local install logic
│   └── examples/
│       └── servers.txt        # Example server list
├── .env                       # Empty (will hold config)
├── .env.example               # Empty (will define all vars)
├── VERSION.md                 # 0.0.0
├── README.md                  # Full documentation
└── LICENSE                    # MIT
```

### Desired Codebase Tree

```
forge-guardian/
├── forge-guardian.sh          # MODIFIED: full implementation with all verbs
├── .env.example               # MODIFIED: all notification/config vars documented
├── original/                  # UNCHANGED: reference only
│   ├── forge-guardian.sh
│   ├── deploy-remote.sh
│   ├── install.sh
│   └── examples/
│       └── servers.txt
├── .env                       # User config (gitignored)
├── VERSION.md
├── README.md
└── LICENSE
```

### Known Gotchas & Framework Quirks

```bash
# CRITICAL: Only edit ABOVE line 172 ("DO NOT MODIFY BELOW THIS LINE")
# The bashew framework code below that line handles all parsing, initialization, etc.

# CRITICAL: run_as_root must be changed from -1 to 0
# Original: run_as_root=-1 (MAY NOT run as root)
# Needed:   run_as_root=0  (don't check - scan/install need root, deploy doesn't)

# CRITICAL: grep -P (PCRE) is NOT available on macOS
# The original uses grep -qPi for malicious signatures
# On macOS (dev), this fails. On Linux (production), it works.
# Use Os:require "grep" and document that scanning needs GNU grep on Linux servers

# CRITICAL: stat command differs between macOS and Linux
# macOS: stat -f%z (file size), stat -f "%OLp" (permissions)
# Linux: stat --printf="%s" (file size), stat -c "%a" (permissions)
# The original handles both - preserve this pattern

# CRITICAL: bashew uses IFS=$'\n\t' - this is stricter than the original
# Be careful with word splitting in arrays and loops

# IMPORTANT: bashew auto-loads .env files from multiple locations
# This is perfect for notification config - user puts slack=https://... in .env
# Variable names from Option:config become .env keys (lowercase long names)

# IMPORTANT: The choice validator in bashew is case-sensitive for the list
# but Script:main() uses ${action,,} for matching - keep verb names lowercase

# IMPORTANT: list type options use -x <val> -x <val2> syntax
# list|s|server|server to deploy to => ${server[@]} array
# Usage: forge-guardian.sh deploy -s host1 -s host2
```

---

## Implementation Blueprint

### Option:config() Design

```bash
function Option:config() {
  grep <<<'
#commented lines will be filtered
flag|h|help|show usage
flag|Q|QUIET|no output
flag|V|VERBOSE|also show debug messages
flag|f|FORCE|do not ask for confirmation (always yes)
option|L|LOG_DIR|folder for log files|$HOME/log/$script_prefix
option|T|TMP_DIR|folder for temp files|/tmp/$script_prefix
option|u|user|SSH user for deploy|root
option|k|key|SSH private key path|$HOME/.ssh/id_rsa
option|p|port|SSH port|22
option|S|servers|file with server list
option|w|slack|Slack webhook URL
option|D|discord|Discord webhook URL
option|G|telegram|Telegram config (bot_token:chat_id)
option|e|email|notification email address
option|m|mode|scan mode: detect/heal/dryrun|detect
option|i|interval|cron interval in minutes|5
option|r|root|root folder for Forge projects|$root
option|q|quarantine|quarantine directory|/opt/forge-guardian/quarantine
list|s|server|server to deploy to
choice|1|action|action to perform|scan,install,deploy,uninstall,check,env,update
' -v -e '^#' -e '^\s*$'
}
```

**Variable mapping:**

| Option            | Variable       | Default                          | Used by         |
|-------------------|----------------|----------------------------------|-----------------|
| `--user`          | `$user`        | `root`                           | deploy          |
| `--key`           | `$key`         | `~/.ssh/id_rsa`                  | deploy          |
| `--port`          | `$port`        | `22`                             | deploy          |
| `--servers`       | `$servers`     | ``                               | deploy (file)   |
| `--server` (list) | `${server[@]}` | `()`                             | deploy (CLI)    |
| `--slack`         | `$slack`       | ``                               | scan, deploy    |
| `--discord`       | `$discord`     | ``                               | scan, deploy    |
| `--telegram`      | `$telegram`    | ``                               | scan, deploy    |
| `--email`         | `$email`       | ``                               | scan, deploy    |
| `--mode`          | `$mode`        | `detect`                         | scan, deploy    |
| `--interval`      | `$interval`    | `5`                              | install, deploy |
| `--root`          | `$root`        | `/home/forge`                    | scan, install   |
| `--quarantine`    | `$quarantine`  | `/opt/forge-guardian/quarantine` | scan            |

### .env.example Design

```bash
# Forge Guardian Configuration
# Copy to .env and fill in your values

# Notification webhooks (leave empty to disable)
slack=""
discord=""
telegram=""
email=""

# Root folder for Forge projects (auto-detect git repos under this path)
root="/home/forge"

# Scan mode: detect (report only) / heal (quarantine + restore) / dryrun (show what heal would do)
mode="detect"

# SSH settings for remote deploy
user="root"
key="$HOME/.ssh/id_rsa"
port="22"

# Cron interval in minutes
interval="5"

# Quarantine directory for healed files
quarantine="/opt/forge-guardian/quarantine"
```

### Constant Data (embedded in script)

Port these arrays from `original/forge-guardian.sh`:
- `ALLOWLIST` array (lines 50-63)
- `SUSPICIOUS_PATTERNS` array (lines 66-80)
- `MALICIOUS_SIGNATURES` array (lines 83-104)

These are readonly arrays defined at the top of the helper functions section.

### Script:main() Dispatch

```bash
function Script:main() {
  IO:log "[$script_basename] $script_version started"
  case "${action,,}" in
  scan)     do_scan ;;
  install)  do_install ;;
  deploy)   do_deploy ;;
  uninstall) do_uninstall ;;
  check|env) Script:check ;;
  update)   Script:git_pull ;;
  *)        IO:die "action [$action] not recognized" ;;
  esac
  IO:log "[$script_basename] ended after $SECONDS secs"
}
```

---

## Task List (in execution order)

### Task 1: Update script metadata and Option:config()

```yaml
MODIFY forge-guardian.sh:
  - CHANGE run_as_root from -1 to 0
  - REPLACE Option:config() with full flag/option/list/choice definitions
  - REPLACE Script:main() with verb dispatch to do_scan, do_install, do_deploy, do_uninstall
  - REMOVE placeholder do_action1() and do_action2() functions
  - ADD TIP comments for each verb
```

**Pseudocode:**
```bash
# Change line 61:
readonly run_as_root=0  # 0 = don't check (scan/install need root, deploy doesn't)

# Option:config() as designed above

# Script:main() as designed above
```

### Task 2: Define constant arrays (scan patterns)

```yaml
ADD after Script:main() closing brace:
  - DEFINE readonly ALLOWLIST array (from original/forge-guardian.sh lines 50-63)
  - DEFINE readonly SUSPICIOUS_PATTERNS array (from original lines 66-80)
  - DEFINE readonly MALICIOUS_SIGNATURES array (from original lines 83-104)
```

**Pseudocode:**
```bash
# These are constant arrays used by the scan detectors
# Ported from original/forge-guardian.sh

readonly -a FG_ALLOWLIST=(
    "storage/framework/cache/*"
    "storage/framework/sessions/*"
    "storage/framework/views/*"
    "storage/logs/*"
    "storage/app/*"
    "bootstrap/cache/*"
    ".env"
    "vendor/*"
    "node_modules/*"
    "public/build/*"
    "public/hot"
    "public/storage"
)

readonly -a FG_SUSPICIOUS_PATTERNS=(
    'cache[0-9]*\.php'
    'config[0-9]*\.php'
    # ... (all from original lines 67-79)
)

readonly -a FG_MALICIOUS_SIGNATURES=(
    'eval\s*(\s*base64_decode'
    'eval\s*(\s*gzinflate'
    # ... (all from original lines 84-103)
)
```

### Task 3: Implement scan helper functions

```yaml
ADD helper functions:
  - is_allowlisted() - check path against FG_ALLOWLIST (from original lines 162-171)
  - scan_file_content() - grep for malicious signatures (from original lines 174-199)
  - is_suspicious_filename() - check against FG_SUSPICIOUS_PATTERNS (from original lines 202-211)
  - quarantine_file() - move file preserving dir structure (from original lines 214-232)
  - git_restore_file() - git checkout tracked file (from original lines 235-248)
  - remove_untracked() - quarantine or delete untracked file (from original lines 251-265)
```

**Key adaptations for bashew:**
```bash
function is_allowlisted() {
    local filepath="$1"
    for pattern in "${FG_ALLOWLIST[@]}"; do
        # shellcheck disable=SC2254
        case "$filepath" in
            $pattern) return 0 ;;
        esac
    done
    return 1
}

function scan_file_content() {
    local filepath="$1"
    # Skip non-PHP files
    [[ ! "$filepath" =~ \.(php|phtml|pht|php[0-9]|inc)$ ]] && return 1
    # Skip files > 5MB
    local filesize
    filesize=$(stat -f%z "$filepath" 2>/dev/null || stat --printf="%s" "$filepath" 2>/dev/null || echo "0")
    (( filesize > 5242880 )) && return 1

    for sig in "${FG_MALICIOUS_SIGNATURES[@]}"; do
        if grep -qPi "$sig" "$filepath" 2>/dev/null; then
            IO:alert "MALICIOUS SIGNATURE in $filepath: matches '$sig'"
            return 0
        fi
    done
    return 1
}

function quarantine_file() {
    local filepath="$1"
    local project_dir="$2"
    local run_id
    run_id=$(date '+%Y%m%d_%H%M%S')_$$
    local relative_path="${filepath#$project_dir/}"
    local quarantine_path="${quarantine}/${run_id}/${project_dir##*/}/${relative_path}"

    mkdir -p "$(dirname "$quarantine_path")"

    if [[ "$mode" == "dryrun" ]]; then
        IO:print "[DRY-RUN] Would quarantine: $filepath -> $quarantine_path"
        return
    fi
    cp -p "$filepath" "$quarantine_path" 2>/dev/null || true
    rm -f "$filepath"
    IO:alert "QUARANTINED: $filepath -> $quarantine_path"
}

function git_restore_file() {
    local filepath="$1"
    local project_dir="$2"
    if [[ "$mode" == "dryrun" ]]; then
        IO:print "[DRY-RUN] Would git restore: $filepath"
        return
    fi
    (cd "$project_dir" && git checkout -- "$filepath" 2>/dev/null) && \
        IO:success "RESTORED from git: $filepath" || \
        IO:alert "Failed to git-restore: $filepath"
}
```

### Task 4: Implement detection functions

```yaml
ADD detection functions (ported from original/forge-guardian.sh):
  - detect_git_anomalies()      - lines 310-394 of original
  - detect_webroot_injections() - lines 399-448 of original
  - detect_recent_changes()     - lines 453-487 of original
  - detect_suspicious_crons()   - lines 492-522 of original
  - detect_bad_permissions()    - lines 527-549 of original
```

**Key adaptations for bashew:**
```bash
# Replace echo/alert/warn/log with IO:print/IO:alert/IO:debug
# Replace $DRY_RUN/$AUTO_HEAL with $mode checks:
#   "detect" = report only
#   "heal"   = quarantine + restore
#   "dryrun" = report what would be done
# Replace direct ((THREATS_FOUND++)) with function return + caller tracking
# Use IO:debug for verbose output instead of custom log_verbose
```

Each detector takes `$project_dir` as argument and returns the number of threats found. The caller accumulates the total.

### Task 5: Implement notification function

```yaml
ADD send_notifications() function:
  - Slack via curl (from original lines 274-279)
  - Discord via curl (from original lines 282-287)
  - Email via mail command (from original lines 290-293)
  - Telegram via curl (from original lines 296-304)
  - Use $slack, $discord, $email, $telegram variables from Option:config
  - For telegram: split on ":" to get bot_token and chat_id
```

**Pseudocode:**
```bash
function send_notifications() {
    local message="$1"
    local hostname
    hostname=$(hostname)

    if [[ -n "${slack:-}" ]]; then
        IO:debug "Sending Slack notification"
        curl -s -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"Forge Guardian Alert - ${hostname}\n\n${message}\"}" \
            "$slack" > /dev/null 2>&1 || true
    fi
    # ... discord, email, telegram similarly
}
```

### Task 6: Implement do_scan()

```yaml
ADD do_scan() function:
  - Auto-detect projects: find $root -maxdepth 2 -type d -name .git
  - Extract parent dir of each .git to get project dirs
  - For each project: run all 5 detectors
  - Accumulate threats_found count
  - If threats > 0: send notifications, exit 1
  - If clean: IO:success "All clear", exit 0
```

**Pseudocode:**
```bash
function do_scan() {
    Os:require "git"
    Os:require "grep"

    IO:print "Forge Guardian Scan - Mode: $mode"

    # Auto-detect projects
    local -a project_dirs=()
    while IFS= read -r -d '' gitdir; do
        project_dirs+=("$(dirname "$gitdir")")
    done < <(find $root -maxdepth 2 -type d -name .git -print0 2>/dev/null)

    if [[ ${#project_dirs[@]} -eq 0 ]]; then
        IO:alert "No git projects found under $root/"
        return 1
    fi

    IO:print "Found ${#project_dirs[@]} project(s)"

    local threats_found=0
    mkdir -p "$quarantine"

    for dir in "${project_dirs[@]}"; do
        IO:print "Project: $dir"
        threats_found=$((threats_found + $(detect_git_anomalies "$dir")))
        threats_found=$((threats_found + $(detect_webroot_injections "$dir")))
        threats_found=$((threats_found + $(detect_recent_changes "$dir")))
        threats_found=$((threats_found + $(detect_bad_permissions "$dir")))
    done
    threats_found=$((threats_found + $(detect_suspicious_crons)))

    if (( threats_found > 0 )); then
        IO:alert "TOTAL THREATS FOUND: ${threats_found}"
        local summary="Host: $(hostname)\nThreats: ${threats_found}\nMode: ${mode}"
        send_notifications "$summary"
        return 1
    else
        IO:success "All clear - no threats detected"
        return 0
    fi
}
```

**IMPORTANT pattern**: Each detect_* function must echo (print to stdout) the count of threats found as its last output, since we capture it with `$(...)`. Use IO:alert (stderr) for messages, and echo the count to stdout. Alternatively, use a global variable or temp file. The cleanest approach: use a global `threats_found` variable incremented inside each detector (simpler, matches the original).

**Revised approach**: Use a global variable `threats_found=0` in do_scan, and each detector increments it directly. Don't capture output.

```bash
function do_scan() {
    threats_found=0  # global, incremented by detectors
    # ... detect calls ...
    detect_git_anomalies "$dir"
    detect_webroot_injections "$dir"
    # etc.
}
```

### Task 7: Implement do_install()

```yaml
ADD do_install() function:
  - Check running as root (or with sudo)
  - Create /opt/forge-guardian/ and quarantine dir
  - Copy script to /opt/forge-guardian/forge-guardian.sh
  - chmod +x
  - Create /var/log/forge-guardian.log
  - Set up cron job (idempotent): */N * * * * forge-guardian.sh scan --mode <mode>
  - Set up logrotate config
  - Run initial dry-run scan
```

**Pseudocode:**
```bash
function do_install() {
    # Check if we can write to /opt
    [[ ! -w /opt ]] && IO:die "Need root/sudo to install to /opt/forge-guardian/"

    local install_dir="/opt/forge-guardian"
    mkdir -p "${install_dir}/quarantine"

    # Copy self
    cp "$script_install_path" "${install_dir}/forge-guardian.sh"
    chmod +x "${install_dir}/forge-guardian.sh"

    # Copy .env if exists
    [[ -f "$script_install_folder/.env" ]] && \
        cp "$script_install_folder/.env" "${install_dir}/.env"

    # Create log
    touch /var/log/forge-guardian.log

    # Cron job (idempotent)
    local cron_cmd="*/${interval} * * * * ${install_dir}/forge-guardian.sh scan --mode ${mode} >> /var/log/forge-guardian.log 2>&1"
    (crontab -l 2>/dev/null | grep -v 'forge-guardian' || true; echo "$cron_cmd") | crontab -
    IO:success "Cron job installed: every ${interval} minutes"

    # Logrotate
    cat > /etc/logrotate.d/forge-guardian << 'LOGROTATE'
/var/log/forge-guardian.log {
    weekly
    rotate 12
    compress
    missingok
    notifempty
}
LOGROTATE
    IO:success "Logrotate configured"

    IO:success "Forge Guardian installed to ${install_dir}"
    IO:print "Running initial scan (dry-run)..."
    "${install_dir}/forge-guardian.sh" scan --mode dryrun -V || true
}
```

### Task 8: Implement do_deploy()

```yaml
ADD do_deploy() function:
  - Collect servers from ${server[@]} array and --servers file
  - Validate at least 1 server specified
  - For each server:
    1. Test SSH connection
    2. SCP forge-guardian.sh to remote /opt/forge-guardian/
    3. SCP .env if exists
    4. SSH: run forge-guardian.sh install remotely
  - Report success/failure count

ADD ssh_cmd() helper - SSH with configured user/key/port
ADD scp_cmd() helper - SCP with configured user/key/port
```

**Pseudocode:**
```bash
function ssh_cmd() {
    local srv="$1"; shift
    ssh -o StrictHostKeyChecking=accept-new \
        -o ConnectTimeout=10 \
        -i "$key" -p "$port" \
        "${user}@${srv}" "$@"
}

function scp_cmd() {
    local src="$1" srv="$2" dest="$3"
    scp -o StrictHostKeyChecking=accept-new \
        -o ConnectTimeout=10 \
        -i "$key" -P "$port" \
        "$src" "${user}@${srv}:${dest}"
}

function do_deploy() {
    Os:require "ssh"
    Os:require "scp"

    # Collect servers
    local -a all_servers=("${server[@]}")

    # Add servers from file
    if [[ -n "${servers:-}" ]]; then
        [[ ! -f "$servers" ]] && IO:die "Servers file not found: $servers"
        while IFS= read -r line; do
            line=$(echo "$line" | sed 's/#.*//' | xargs)
            [[ -n "$line" ]] && all_servers+=("$line")
        done < "$servers"
    fi

    [[ ${#all_servers[@]} -eq 0 ]] && IO:die "No servers specified. Use -s <host> or --servers <file>"

    IO:print "Deploying to ${#all_servers[@]} server(s)"

    local succeeded=0 failed=0
    for srv in "${all_servers[@]}"; do
        IO:announce "Deploying to ${user}@${srv}:${port}"

        # Test connection
        if ! ssh_cmd "$srv" "echo OK" &>/dev/null; then
            IO:alert "Cannot SSH to $srv"
            ((failed++))
            continue
        fi
        IO:debug "SSH connection OK"

        # Upload
        ssh_cmd "$srv" "mkdir -p /opt/forge-guardian"
        scp_cmd "$script_install_path" "$srv" "/opt/forge-guardian/forge-guardian.sh"

        # Upload .env if exists
        if [[ -f "$script_install_folder/.env" ]]; then
            scp_cmd "$script_install_folder/.env" "$srv" "/opt/forge-guardian/.env"
        fi

        # Remote install
        ssh_cmd "$srv" "/opt/forge-guardian/forge-guardian.sh install --mode ${mode} --interval ${interval}"
        IO:success "Deployed to $srv"
        ((succeeded++))
    done

    IO:print "Done: ${succeeded} succeeded, ${failed} failed"
    [[ $failed -eq 0 ]] || return 1
}
```

### Task 9: Implement do_uninstall()

```yaml
ADD do_uninstall() function:
  - Remove cron entry
  - Remove script (preserve quarantine if non-empty)
  - Remove logrotate config
  - Preserve log file
```

**Pseudocode:**
```bash
function do_uninstall() {
    IO:print "Uninstalling Forge Guardian..."

    # Remove cron
    (crontab -l 2>/dev/null | grep -v 'forge-guardian' || true) | crontab -
    IO:success "Cron entry removed"

    # Remove files (preserve quarantine)
    local install_dir="/opt/forge-guardian"
    if [[ -d "${install_dir}/quarantine" ]] && [[ -n "$(ls -A "${install_dir}/quarantine" 2>/dev/null)" ]]; then
        IO:alert "Preserving quarantine directory: ${install_dir}/quarantine/"
        rm -f "${install_dir}/forge-guardian.sh"
        rm -f "${install_dir}/.env"
    else
        rm -rf "${install_dir}"
    fi

    rm -f /etc/logrotate.d/forge-guardian
    IO:success "Forge Guardian uninstalled"
    IO:print "Log file preserved: /var/log/forge-guardian.log"
}
```

### Task 10: Update .env.example

```yaml
MODIFY .env.example:
  - Add all notification webhook variables
  - Add scan mode and interval defaults
  - Add SSH deploy defaults
  - Add quarantine directory
  - Add comments explaining each variable
```

---

## Integration Points

```yaml
CRON:
  - install verb creates: "*/5 * * * * /opt/forge-guardian/forge-guardian.sh scan --mode detect >> /var/log/forge-guardian.log 2>&1"
  - interval configurable via --interval option

LOGROTATE:
  - install verb creates: /etc/logrotate.d/forge-guardian

SSH/SCP:
  - deploy verb uses: ssh -i $key -p $port $user@$server
  - deploy verb uses: scp -i $key -P $port

ENV:
  - bashew auto-loads .env files (script folder + cwd)
  - notification config in .env overridden by CLI flags
  - deployed .env is copied to /opt/forge-guardian/.env on remote

FILESYSTEM:
  - /opt/forge-guardian/forge-guardian.sh     (installed script)
  - /opt/forge-guardian/.env                  (config)
  - /opt/forge-guardian/quarantine/           (quarantined files)
  - /var/log/forge-guardian.log              (log output)
  - /etc/logrotate.d/forge-guardian          (log rotation config)
```

---

## Validation Loop

### Level 1: Syntax & Static Analysis

```bash
# Syntax check
bash -n forge-guardian.sh

# ShellCheck (fix all warnings, add SC directives where needed)
shellcheck forge-guardian.sh

# Expected: No errors
```

### Level 2: Functional Tests

```bash
# Test help output
./forge-guardian.sh -h

# Test check verb (shows all config values)
./forge-guardian.sh check

# Test env verb (generates .env template)
./forge-guardian.sh env > /tmp/test.env

# Test scan verb fails gracefully when not on a Forge server
./forge-guardian.sh scan 2>&1 || echo "Expected: no projects found"

# Test deploy verb fails gracefully with no servers
./forge-guardian.sh deploy 2>&1 || echo "Expected: no servers specified"

# Test unknown action
./forge-guardian.sh badaction 2>&1 || echo "Expected: action not recognized"
```

### Level 3: Integration Verification

```bash
# Verify all verbs are listed in help
./forge-guardian.sh -h | grep -E "scan|install|deploy|uninstall"

# Verify .env loading works
echo 'slack="https://test"' > /tmp/test.env
# (would need to test with actual .env in script folder)

# Verify script can be sourced without executing (bashew feature)
source forge-guardian.sh  # should not execute Script:main
```

---

## Final Validation Checklist

- [ ] `bash -n forge-guardian.sh` passes (syntax check)
- [ ] `shellcheck forge-guardian.sh` passes (or only acceptable SC directives)
- [ ] `./forge-guardian.sh -h` shows all verbs and options
- [ ] `./forge-guardian.sh check` shows all config values
- [ ] `./forge-guardian.sh scan` runs (fails gracefully if no $root/)
- [ ] `./forge-guardian.sh deploy` fails with helpful error when no servers given
- [ ] All 5 detectors from original are ported (git anomalies, webroot, recent changes, crons, permissions)
- [ ] All malicious signatures from original are included
- [ ] All suspicious filename patterns from original are included
- [ ] Notification functions support Slack, Discord, Telegram, Email
- [ ] .env.example documents all configurable variables
- [ ] No code modified below "DO NOT MODIFY BELOW THIS LINE" (line 172)
- [ ] TIP comments added for each verb

---

## Anti-Patterns to Avoid

- Do NOT modify bashew framework code below line 172
- Do NOT hardcode project directories — always auto-detect via `find`
- Do NOT use `echo` for output — use `IO:print`, `IO:alert`, `IO:debug`, `IO:success`
- Do NOT use `exit` directly — use `IO:die` or `return`
- Do NOT use `$DRY_RUN` / `$AUTO_HEAL` booleans — use `$mode` (detect/heal/dryrun)
- Do NOT create separate scripts — everything goes in the single forge-guardian.sh
- Do NOT use backticks — use `$(command)` substitution
- Do NOT use unquoted variables — always `"${var}"`
- Do NOT skip the `# shellcheck disable=SCXXXX` directives where needed
- Do NOT forget that `IFS=$'\n\t'` is set (bashew strict mode) — word splitting works differently

---

## Confidence Score: 8/10

**Why 8 and not higher:**
- The scan detectors are well-documented in the original and straightforward to port
- The bashew framework provides solid scaffolding
- The `list` type for servers and .env for config are clean patterns
- Risk areas: grep -P compatibility (macOS vs Linux), stat command differences, the IFS setting affecting array iteration in detection loops
- The deploy verb has SSH complexity but follows a clear pattern from the original

**What could improve confidence:**
- Having a test server to validate SSH deploy
- More specific tests for the detection functions
- Handling edge cases around the `find $root` path on non-Forge systems
